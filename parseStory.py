"""
Converts the Dragalia Wiki team's extracted Story MonoBehaviour txt scripts
into partial or full wikitext templating.
"""

import glob
import re
import sqlite3
from collections import OrderedDict
from storyMonoParser import toDict


INPUT_PATH = '../09_30_2019_DataDump/Story'
OUTPUT_PATH = '../output'
DB_PATH = '../output/data.db'
TEXT_LABEL_FILE = '../09_30_2019_DataDump/ParsedMonos/TextLabel.txt'

TEXT_LABELS = {}
EVENT_TYPES = {
  '1': 'Raid',
  '3': 'Facility',
  '4': 'Story',
  '5': 'Defensive',
}
IGNORABLE_PREFIXES = '|'.join((
  'Reset',
  'Restart',
  'Stop',
  '[A-Z0-9]+_',
  'c_',
  'chara_',
  'cmp_',
  'cut_',
  'cutt_',
  'effect_',
  'mnu_',
  'screen_',
  'set_',
  'touch_',
  'window_',
))
IGNORED_COMMAND_REGEXES = re.compile('^(' + IGNORABLE_PREFIXES + ')')
IGNORED_COMMAND_TYPES = (
  'blur',
  'cmp',
  'else',
  'endif',
  'eye1',
  'fade_color',
  'fin',
  'frame_visible',
  'if',
  'kosokoso',
  'lip1',
  'mnu',
  'next_page',
  'play_sound',
  'post_film',
  'show_prologue_book',
  'stop_bgm',
  'stop_se',
  'wait',
)
ENTRY_LINE_BREAK = '\n=============================\n'
c = None


# Would prefer to use namedtuples, but can't since the fields start with '_'
def row_factory(cursor, row):
  return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}


def to_wikitext(filename, story):
  # Unit
  if '/unitstory/' in filename:
    if '/chara/' in filename:
      return chara_template(story)
    if '/dragon/' in filename:
      return dragon_template(story)
  # Quest (Event / Campaign)
  elif '/queststory/' in filename:
    return event_template(story)
  # On promotion to 5*
  elif '/awakeningstory/' in filename:
    line = story['lines'][0]
    return (line['speaker'] + '\n;On Promotion to {{5*}}\n:' + line['quote'] + '\n\n')
  else:
    print(f'Unknown story type, some template fields will not be autogenerated')
    return dialogue_to_wikitext(story['lines'])


def chara_template(story):
  story_id = story['id']
  title = TEXT_LABELS.get(f"STORY_UNIT_NAME_{story['id']}", "")

  c.execute(f"SELECT _ReleaseTriggerId,_ReleaseStep FROM 'UnitStory' "
            f"WHERE _Id='{story_id}'")
  result = c.fetchone()
  index = int(result['_ReleaseStep']) + 1
  adv_id = result['_ReleaseTriggerId']
  adv_name = TEXT_LABELS.get(f"CHARA_NAME_COMMENT_{adv_id}",
                             TEXT_LABELS.get(f"CHARA_NAME_{adv_id}", "")
                            ).replace('{player_name}', 'Euden')

  return (f"Adventurer Story: {adv_name}\n"
          f"|episode{index}Title = {title}\n"
          f"|episode{index}Content = {dialogue_to_wikitext(story)}\n\n")


def dragon_template(story):
  story_id = story['id']
  title = TEXT_LABELS.get(f"STORY_UNIT_NAME_{story['id']}", "")

  c.execute(f"SELECT _ReleaseTriggerId FROM 'UnitStory' "
            f"WHERE _Id='{story_id}'")
  result = c.fetchone()
  index = story_id[-1]
  dragon_id = result['_ReleaseTriggerId']
  dragon_name = TEXT_LABELS.get(f"DRAGON_NAME_COMMENT_{dragon_id}",
                                TEXT_LABELS.get(f"DRAGON_NAME_{dragon_id}", ""))
  lines = '\n\n\n'.join([l['quote'] for l in story['lines']])

  return (f"Dragon Story: {dragon_name}\n"
          f"|StoryName = {title}\n"
          f"|episode{index}Content = {lines}\n\n")


def event_template(story):
  story_id = story['id']
  title = TEXT_LABELS.get(f"STORY_QUEST_NAME_{story_id}", "")
  section_name = TEXT_LABELS.get(f"STORY_QUEST_TITLE_{story_id}", "")

  c.execute(f"SELECT QuestEvent._Id as event_id,_QuestEventType,_ReleaseQuestId,_ReleaseQuestType,_IsEpilogue,_ThumbnailImage FROM 'QuestStory' "
            f"JOIN 'QuestEvent' ON QuestStory._GroupId = QuestEvent._Id "
            f"JOIN 'QuestEventMenu' ON QuestStory._ID = _EntryQuestId "
            f"WHERE _EntryQuestId='{story_id}'")
  quest = c.fetchone()
  event_id = quest['event_id']
  event_type = EVENT_TYPES[quest['_QuestEventType']]
  event_name = TEXT_LABELS.get(f"EVENT_NAME_{event_id}", "")
  prev_quest_id = quest['_ReleaseQuestId']
  prev_quest_type = quest['_ReleaseQuestType']
  prev_quest_title = ""
  next_quest_title = ""

  if prev_quest_id != '0':
    if prev_quest_type == '2':  # Story
      prev_quest_title = TEXT_LABELS.get(f"STORY_QUEST_NAME_{prev_quest_id}", "")
    if prev_quest_type == '1':  # Battle
      prev_quest_title = TEXT_LABELS.get(f"QUEST_NAME_{prev_quest_id}", "")

  if quest['_IsEpilogue'] == '0':
    c.execute(f"SELECT _EntryQuestId,_EntryQuestType FROM 'QuestEventMenu' "
              f"WHERE _ReleaseQuestId='{story_id}'")
    next_quest = c.fetchone()
    next_quest_id = next_quest['_EntryQuestId']
    next_quest_type = next_quest['_EntryQuestType']
    if next_quest_type == '2':  # Story
      next_quest_title = TEXT_LABELS.get(f"STORY_QUEST_NAME_{next_quest_id}", "")
    elif next_quest_type == '1':  # Battle
      next_quest_title = TEXT_LABELS.get(f"QUEST_NAME_{next_quest_id}", "")
    else:
      print(f'Unknown next quest type, some template fields will not be autogenerated')

  return ("{{EventStoryHeader\n"
          f"|EventType = {event_type}\n"
          f"|EventName = {event_name}\n"
          f"|SectionName = {section_name}\n"
          f"|QuestViewName = {title}\n"
          f"|NextQuest = {next_quest_title}\n"
          f"|PreviousQuest = {prev_quest_title}\n"
          f"|ThumbnailImage = {quest['_ThumbnailImage']}\n"
          f"|Summary = {story['summary']}\n"
          f"|Dialogue = {dialogue_to_wikitext(story)}\n"
          "}}\n\n")


def dialogue_to_wikitext(story):
  dialogue = ['<div align="left">']
  for l in story['lines']:
    if l['speaker'] == 'book_text':
      dialogue.append(f"{l['quote']}\n")
    elif l['speaker'] == 'SYS':
      dialogue.append(f"<center>''{l['quote']}''</center>")
    else:
      dialogue.append(f"{{{{ST|{l['speaker']}}}}} {l['quote']}")

  dialogue.append('</div>')
  return '\n'.join(dialogue)


def process_txt(filename):
  story_dict = toDict(filename)
  commands = story_dict['functions'][0]['commandList']
  story = {
    'id': story_dict['m_Name'],
    'lines': []
  }

  for command in commands:
    command_type = command['command']
    data = command['args']

    if command_type == 'outline':
      if len(data) and data[0] != 'Skip this scene?':
        story['summary'] = data[0].replace('\\n', ' ')

    elif command_type == 'print':
      speaker = data[0]
      quote = data[1].replace('\\n', ' ').replace('{player_name}', 'Euden')
      if speaker == '{player_name}':
        speaker = 'Euden'
      story['lines'].append({'speaker': speaker, 'quote': quote})

    elif command_type == 'add_book_text': # Dragon stories
      quote = data[0].replace('\\n', '<br>\n').replace('{player_name}', 'Euden')
      story['lines'].append({'speaker': 'book_text', 'quote': quote})

    elif command_type == 'end':
      return story
    elif is_ignorable(command_type):
      continue
    else:
      print(f'Unknown command type: {command}')

  return story


def is_ignorable(command):
  if command.isupper():
    return True
  if IGNORED_COMMAND_REGEXES.match(command):
    return True
  if command in IGNORED_COMMAND_TYPES:
    return True
  return False


def preload_text_labels():
  with open(TEXT_LABEL_FILE, encoding='utf-8') as f:
    for line in f:
      label, text = line.split('\t', 1)
      TEXT_LABELS[label] = text.rstrip()


def main():
  global c
  preload_text_labels()
  conn = sqlite3.connect(DB_PATH)
  conn.row_factory = row_factory
  c = conn.cursor()

  with open(f'{OUTPUT_PATH}/Stories.txt', 'w', encoding='utf-8') as out_file:
    for txt_file in sorted(glob.glob(f'{INPUT_PATH}/**/*.txt', recursive=True)):
      heading = txt_file.split('/story/')[-1].replace('/', '_')
      print(ENTRY_LINE_BREAK + heading + ENTRY_LINE_BREAK)
      story = process_txt(txt_file)
      if len(story['lines']):
        out_file.write(ENTRY_LINE_BREAK)
        out_file.write(heading)
        out_file.write(ENTRY_LINE_BREAK)
        out_file.write(to_wikitext(txt_file, story))
      else:
        print('No lines were parsed out.')

  conn.close()



if __name__ == "__main__":
  main()